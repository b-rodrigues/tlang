# T Package Management System

> A plan for user-contributed packages using Nix flakes for reproducibility

---

## Overview

T's package management philosophy prioritizes reproducibility above all else. Rather than implementing a traditional package manager with version resolution and registry systems, T leverages **Nix flakes** to ensure that projects are perfectly reproducible across all environments.

The core principle: **T's package manager is Nix itself.**

This approach provides:

- **Perfect reproducibility**: Same inputs always produce the same environment
- **No dependency hell**: Nix guarantees consistent package versions
- **Centralized quality**: All packages contributed to the main repository
- **Transparent review**: All contributions via GitHub Pull Requests

---

## Package Structure: `t init package`

### Command

```bash
t init package <package-name>
```

This command creates a folder structure for a new T package, inspired by R package conventions:

### Folder Layout

```
my-package/
├── DESCRIPTION.toml       # Package metadata
├── flake.nix             # Nix flake for the package
├── README.md             # Package documentation
├── LICENSE               # License file (default: EUPL-1.2)
├── CHANGELOG.md          # Version history
├── R/                    # T source files (named after R convention)
│   ├── function1.t
│   ├── function2.t
│   └── helpers.t
├── tests/                # Test files
│   ├── test-function1.t
│   └── test-function2.t
├── examples/             # Example scripts
│   └── demo.t
└── docs/                 # Additional documentation
    └── usage.md
```

### DESCRIPTION.toml

The `DESCRIPTION.toml` file contains package metadata:

```toml
[package]
name = "my-package"
version = "0.1.0"
description = "A brief description of what the package does"
authors = ["Your Name <email@example.com>"]
license = "EUPL-1.2"
homepage = "https://github.com/b-rodrigues/tlang"

[dependencies]
# T packages this package depends on
# Format: package_name = "commit-hash-or-version"
stats = "main"
colcraft = "main"

[t]
# Minimum T language version required
min_version = "0.5.0"
```

### Package flake.nix

Each package includes a `flake.nix` that specifies its build and runtime dependencies:

```nix
{
  description = "My T package";

  inputs = {
    nixpkgs.url = "github:rstats-on-nix/nixpkgs/2026-02-10";
    t-lang.url = "github:b-rodrigues/tlang";
  };

  outputs = { self, nixpkgs, t-lang }:
    let
      system = "x86_64-linux";
      pkgs = nixpkgs.legacyPackages.${system};
    in
    {
      packages.${system}.default = pkgs.stdenv.mkDerivation {
        pname = "t-my-package";
        version = "0.1.0";
        src = ./.;
        
        buildInputs = [ t-lang.packages.${system}.default ];
        
        installPhase = ''
          mkdir -p $out/lib/t/packages/my-package
          cp -r R/* $out/lib/t/packages/my-package/
        '';
      };
    };
}
```

### R/ Directory Convention

Following R's convention, T source files are placed in the `R/` directory:

- Each file should define one or more related functions
- File names should be lowercase with hyphens: `data-manipulation.t`
- Helper functions can be in separate files: `helpers.t`, `utils.t`
- Internal functions should be prefixed with `.` (e.g., `.internal_helper`)

### Example Package Function

File: `R/summarize-numeric.t`

```t
-- Summarize numeric columns with common statistics
summarize_numeric = \(df) -> {
  df |> select_if(\(col) is_numeric(col))
     |> summarize(
          mean = mean(__column__),
          sd = sd(__column__),
          min = min(__column__),
          max = max(__column__)
        )
}
```

---

## Project Structure: `t init project`

### Command

```bash
t init project <project-name>
```

This command creates a reproducible T project with Nix flake configuration:

### Project Layout

```
my-project/
├── flake.nix            # Nix flake with pinned dependencies
├── flake.lock           # Lockfile (auto-generated by Nix)
├── tproject.toml        # T project configuration
├── README.md            # Project documentation
├── .gitignore           # Git ignore patterns
├── src/                 # Project source code
│   └── analysis.t
├── data/                # Data files
│   └── dataset.csv
├── outputs/             # Generated outputs
└── tests/               # Project tests
    └── test-analysis.t
```

### Project flake.nix

The project `flake.nix` pins all dependencies to a specific date from the `rstats-on-nix/nixpkgs` fork:

```nix
{
  description = "My T Data Analysis Project";

  inputs = {
    # Pin to a specific date for reproducibility
    # This ensures the exact same R packages and system dependencies
    nixpkgs.url = "github:rstats-on-nix/nixpkgs/2026-02-10";
    flake-utils.url = "github:numtide/flake-utils";
    t-lang.url = "github:b-rodrigues/tlang/v0.5.0";
  };

  # Configure cachix for R packages
  nixConfig = {
    extra-substituters = [
      "https://rstats-on-nix.cachix.org"
    ];
    extra-trusted-public-keys = [
      "rstats-on-nix.cachix.org-1:vdiiVgocg6WeJrODIqdprZRUrhi1JzhBnXv7aWI6+F0="
    ];
  };

  outputs = { self, nixpkgs, flake-utils, t-lang }:
    flake-utils.lib.eachDefaultSystem (system:
      let
        pkgs = nixpkgs.legacyPackages.${system};
        
        # Custom T packages for this project
        projectPackages = [
          # Add package paths here
        ];

      in
      {
        # Development environment
        devShells.default = pkgs.mkShell {
          buildInputs = [
            t-lang.packages.${system}.default
            pkgs.rPackages.dplyr
            pkgs.rPackages.ggplot2
          ] ++ projectPackages;

          shellHook = ''
            echo "=================================================="
            echo "T Project Environment: my-project"
            echo "=================================================="
            echo ""
            echo "T version: $(t --version)"
            echo "Nixpkgs date: 2026-02-10"
            echo ""
            echo "Available commands:"
            echo "  t repl              - Start T REPL"
            echo "  t run src/analysis.t - Run analysis"
            echo ""
          '';
        };

        # Make the project runnable
        apps.default = {
          type = "app";
          program = "${t-lang.packages.${system}.default}/bin/t";
        };
      }
    );
}
```

### tproject.toml

The `tproject.toml` file specifies project metadata and T package dependencies:

```toml
[project]
name = "my-project"
version = "0.1.0"
description = "Data analysis for customer segmentation"
authors = ["Data Team <data@example.com>"]

[environment]
# Date-pinned nixpkgs from rstats-on-nix
nixpkgs = "github:rstats-on-nix/nixpkgs/2026-02-10"
t_version = "0.5.0"

[dependencies]
# T packages from the main repository
# Format: package = "commit-hash" or "version-tag"
stats = "v0.5.0"
colcraft = "v0.5.0"
dataframe = "v0.5.0"

# User-contributed packages from the community
# Format: package = { git = "url", rev = "commit-hash" }
# my-viz-package = { git = "https://github.com/user/t-viz", rev = "abc123" }

[dependencies.dev]
# Development-only dependencies (for testing, etc.)
# test-helpers = "v0.1.0"

[r-packages]
# R packages available via rstats-on-nix
# These are specified in flake.nix but documented here
dplyr = "*"
ggplot2 = "*"
readr = "*"

[targets]
# Optional: Define project targets (inspired by R's {targets})
# This section is reserved for future pipeline/DAG specification
```

---

## Dependency Resolution

### How It Works

1. **Nix flake lock**: When you run `nix flake lock` in a project, Nix resolves all inputs and creates a `flake.lock` file with exact commits/hashes.

2. **rstats-on-nix date pins**: The nixpkgs input is pinned to a specific date branch (e.g., `2026-02-10`), which corresponds to a snapshot of all R packages at that date.

3. **T package versions**: T packages are referenced by commit hash or version tag, ensuring exact reproducibility.

4. **Transitive dependencies**: All dependencies of dependencies are also pinned through Nix's evaluation.

### Date-Based Pinning

The `rstats-on-nix/nixpkgs` repository maintains branches for each date:

- `https://github.com/rstats-on-nix/nixpkgs/tree/2026-02-10`
- `https://github.com/rstats-on-nix/nixpkgs/tree/2026-02-09`
- `https://github.com/rstats-on-nix/nixpkgs/tree/2026-01-19`

When initializing a project, `t init project` automatically:

1. Gets the current date (e.g., `2026-02-10`)
2. Sets `nixpkgs.url = "github:rstats-on-nix/nixpkgs/2026-02-10"`
3. Runs `nix flake lock` to generate the lockfile

This ensures that running the project in 5 years will use the **exact same** package versions.

---

## Workflow for Package Authors

### Creating a New Package

1. **Initialize package structure**:
   ```bash
   t init package my-awesome-package
   cd my-awesome-package
   ```

2. **Write your T functions** in the `R/` directory:
   ```bash
   # R/cool-function.t
   cool_function = \(x) -> x + 42
   ```

3. **Add tests** in the `tests/` directory:
   ```bash
   # tests/test-cool-function.t
   result = cool_function(8)
   assert(result == 50, "cool_function should add 42")
   ```

4. **Update DESCRIPTION.toml** with metadata

5. **Test your package**:
   ```bash
   nix develop
   t run tests/test-cool-function.t
   ```

6. **Contribute to the main repository**:
   - Fork `https://github.com/b-rodrigues/tlang`
   - Copy your package to `packages/my-awesome-package/`
   - Create a Pull Request
   - Maintainers review and merge

### Package Contribution Guidelines

All packages must:

1. Follow the standard folder structure
2. Include comprehensive tests
3. Have clear documentation in README.md
4. Use semantic versioning
5. Include examples
6. Pass CI checks (linting, tests, builds)
7. Have a EUPL-1.2 compatible license

---

## Workflow for Project Authors

### Starting a New Project

1. **Initialize project**:
   ```bash
   t init project customer-segmentation
   cd customer-segmentation
   ```

2. **Enter development environment**:
   ```bash
   nix develop
   ```

3. **Edit tproject.toml** to add dependencies:
   ```toml
   [dependencies]
   stats = "v0.5.0"
   colcraft = "v0.5.0"
   my-awesome-package = "v0.2.0"
   ```

4. **Update flake.nix** to include the package:
   ```nix
   # In the outputs function
   projectPackages = [
     (import ./packages/my-awesome-package { inherit pkgs; })
   ];
   ```

5. **Lock dependencies**:
   ```bash
   nix flake lock
   ```

6. **Write your analysis** in `src/`:
   ```bash
   # src/analysis.t
   data = read_csv("data/customers.csv")
   result = data |> cool_function()
   ```

7. **Run your analysis**:
   ```bash
   t run src/analysis.t
   ```

### Sharing Your Project

When sharing a project with collaborators:

1. **Commit flake.lock** to version control
2. **Share the repository** (e.g., GitHub)
3. **Collaborators run**:
   ```bash
   git clone <repo-url>
   cd <repo>
   nix develop
   ```

The exact same environment will be reproduced, regardless of:
- Operating system (Linux, macOS)
- Time (works the same in 5 years)
- Global system packages

---

## Reproducibility Guarantees

### What is Guaranteed

1. **Exact package versions**: All T packages, R packages, and system libraries are pinned
2. **Build reproducibility**: Same source code produces identical binaries
3. **Environment isolation**: No interference from global packages
4. **Time independence**: Locked projects work identically years later

### What is NOT Guaranteed

1. **Data reproducibility**: Data files must be version-controlled separately
2. **Random seeds**: Use explicit `set_seed()` calls in T code
3. **External APIs**: Web APIs may change; cache responses when possible

---

## Migration from Traditional Package Managers

### Comparison with npm/PyPI/CRAN

| Feature | npm/PyPI | CRAN | T (Nix) |
|---------|----------|------|---------|
| **Reproducibility** | Lockfiles (fragile) | Single version policy | Perfect (Nix) |
| **Contribution** | Decentralized | Centralized, opaque | Centralized, transparent |
| **Dependency Hell** | Common | Rare | Impossible |
| **Version Conflicts** | Common | Managed | Impossible |
| **Setup Complexity** | Low | Low | Medium (learning Nix) |
| **Long-term Stability** | Poor | Good | Excellent |

### Why Not a Traditional Package Manager?

T deliberately avoids:

1. **Version resolution algorithms**: Nix handles this perfectly
2. **Package registries**: Centralized Git repository is simpler
3. **Dependency hell**: Nix makes it impossible
4. **Breaking changes**: Date-pinning prevents surprise breakage

The tradeoff is a steeper learning curve (Nix), but the payoff is **guaranteed reproducibility**.

---

## Future Enhancements

### Planned Features

- [ ] `t install <package>`: Add package to tproject.toml and update flake.nix
- [ ] `t update`: Update packages to latest versions
- [ ] `t test`: Run all package/project tests
- [ ] `t publish`: Automated PR creation for package contribution
- [ ] `t doctor`: Verify project setup and dependencies

### Package Registry

In the future, we may add:

- Web UI for browsing available packages
- Automated documentation generation
- Package download statistics
- Dependency graph visualization

All packages would still be managed through the main repository.

---

## Examples

### Example 1: Simple Analysis Package

```bash
# Create package
t init package simple-stats

# Edit R/descriptives.t
cat > R/descriptives.t <<EOF
describe = \(df) -> {
  df |> summarize(
    count = n(),
    mean = mean(__column__),
    sd = sd(__column__),
    min = min(__column__),
    max = max(__column__)
  )
}
EOF

# Test it
nix develop
t repl
```

### Example 2: Data Analysis Project

```bash
# Create project
t init project sales-analysis

# Enter environment
nix develop

# Add data
cp ~/sales_2026.csv data/

# Write analysis
cat > src/analyze.t <<EOF
sales = read_csv("data/sales_2026.csv")

monthly = sales 
  |> mutate(month = extract_month(date))
  |> group_by(month)
  |> summarize(total = sum(amount))

print(monthly)
EOF

# Run
t run src/analyze.t
```

### Example 3: Collaborative Research

Researcher A sets up a project:

```bash
t init project climate-analysis
cd climate-analysis

# Edit tproject.toml to add dependencies
# Commit to GitHub
git add .
git commit -m "Initial setup"
git push
```

Researcher B reproduces the exact environment:

```bash
git clone <repo>
cd climate-analysis
nix develop  # Exact same environment!
t run src/analysis.t  # Identical results
```

---

## Conclusion

T's package management system leverages Nix flakes to provide:

1. **Perfect reproducibility** through date-pinned nixpkgs
2. **Centralized quality** through the main repository
3. **Zero dependency conflicts** through Nix's isolation
4. **Long-term stability** through immutable package snapshots

The workflow is simple:
- **Package authors**: `t init package` → develop → PR to main repo
- **Project authors**: `t init project` → add dependencies to tproject.toml → `nix develop`

This ensures that **T's package manager is Nix itself**, providing reproducibility guarantees that traditional package managers cannot match.
